首先观察python代码，发现其为标准rsa加密过程。

由于已知N、d，使用rsatools对其进行破解，获取相应的p与q，从而获取phi。

除此之外，通过访问factordb，发现e\*d-1即k\*phi在其中存有数据，故将其因子遍历即可获取phi，本方法代码放在最后。

通过phi计算friends_key中的私钥，即[107273, 80021, 110281, 125399, 77641]在phi下的逆元，而后只需将c进行逆元的乘方即可获取明文。



```python
from Crypto.Util.number import *
import gmpy2 as gmpy
import random,base64
from math import gcd

DEFAULT_EXP = 65537
def factor_modulus(n, d, e):
    """
    Efficiently recover non-trivial factors of n
    See: Handbook of Applied Cryptography
    8.2.2 Security of RSA -> (i) Relation to factoring (p.287)
    http://www.cacr.math.uwaterloo.ca/hac/
    """
    t = (e * d - 1)
    s = 0

    while True:
        quotient, remainder = divmod(t, 2)

        if remainder != 0:
            break

        s += 1
        t = quotient

    found = False

    while not found:
        i = 1
        a = random.randint(1, n-1)

        while i <= s and not found:
            c1 = pow(a, pow(2, i-1, n) * t, n)
            c2 = pow(a, pow(2, i, n) * t, n)

            found = c1 != 1 and c1 != (-1 % n) and c2 == 1

            i += 1

    p = gcd(c1-1, n)
    q = n // p

    return p, q


class RSA:
    def __init__(self, p=None, q=None, n=None, d=None, e=DEFAULT_EXP):
        """
        Initialize RSA instance using primes (p, q)
        or modulus and private exponent (n, d)
        """

        self.e = e

        if p and q:
            assert gmpy.is_prime(p), 'p is not prime'
            assert gmpy.is_prime(q), 'q is not prime'

            self.p = p
            self.q = q
        elif n and d:
            self.p, self.q = factor_modulus(n, d, e)
        else:
            raise ArgumentError('Either (p, q) or (n, d) must be provided')

        self._calc_values()

    def _calc_values(self):
        self.n = self.p * self.q

        if self.p != self.q:
            phi = (self.p - 1) * (self.q - 1)
        else:
            phi = (self.p ** 2) - self.p

        self.d = gmpy.invert(self.e, phi)

        # CRT-RSA precomputation
        self.dP = self.d % (self.p - 1)
        self.dQ = self.d % (self.q - 1)
        self.qInv = gmpy.invert(self.q, self.p)


N = 15029760235374231085969639414731714595094502023579580515142415364576906256445975070594748351717296265506796113025536826427911733196972964855469386448087417878697745924349624863909303165292167253527223263941652633363973854290523602860560486258509324353520104509387932968280508674316342236523385959602558170958614970693493378178016898028008319433088550790771390116863660130486812753414200478905354927474330477084174838392457570478397763649784441576899752400739324537777431123697771882670997321209911034933464741353255233083149611904906129535499692359926063803373853328404277847957250932127456840832115242266989310408337


d = 6510060024132448812692374598562478938781873276826121917136087171433612126001066486549172550775880633671688073309060742661536694848138785012316851139079566219427085669995770343650050947604387625705743119055063449704794632066543990637391557798194976737161835401498317792553501071727695913273255675957670000137254200491232988916899437811704442351184491702933366588255664254218916419493613957433723990485119540500734398920034539046985131363424063852960232153505171116298416691316690158260663800875225380729824947022224315510290836013992740531252154869626076244458736535349817731705617890688617614422279803126347527748253

e = 0x10001

rsa = RSA(n=N, d=d, e=e)

p = rsa.p
q = rsa.q

phi = (p-1)*(q-1)


ps = [107273, 80021, 110281, 125399, 77641]

ds = [] 

for i in range(len(ps)):
    ds.append(inverse(ps[i], phi))

c = 2621668640772056420471560098924704127784856790481388457844412769822118088860174800889321751481674422274270598394172919656578632970378187564960846030071830293875552723490431731972841568891484366856527528595054839456764493791012121047269761236912586905892771816051261702781783915560998982829509529868080760864895962974173385898354122495270178096361803788632815673814331531474332060419597040425174040815031894440262657639509623993308964349172916870911290368660953787873798343194799625182081014696063160131605363197089825537641567810410348240587342655465209891653946637101421879415183319402455214734741851508514452049810

for i in range(len(ds)):
    c = pow(c, ds[i], N)

print(long_to_bytes(c))


```



另一种方法：

```python
from Crypto.Util.number import *
import gmpy2
from itertools import combinations

N = 15029760235374231085969639414731714595094502023579580515142415364576906256445975070594748351717296265506796113025536826427911733196972964855469386448087417878697745924349624863909303165292167253527223263941652633363973854290523602860560486258509324353520104509387932968280508674316342236523385959602558170958614970693493378178016898028008319433088550790771390116863660130486812753414200478905354927474330477084174838392457570478397763649784441576899752400739324537777431123697771882670997321209911034933464741353255233083149611904906129535499692359926063803373853328404277847957250932127456840832115242266989310408337


d = 6510060024132448812692374598562478938781873276826121917136087171433612126001066486549172550775880633671688073309060742661536694848138785012316851139079566219427085669995770343650050947604387625705743119055063449704794632066543990637391557798194976737161835401498317792553501071727695913273255675957670000137254200491232988916899437811704442351184491702933366588255664254218916419493613957433723990485119540500734398920034539046985131363424063852960232153505171116298416691316690158260663800875225380729824947022224315510290836013992740531252154869626076244458736535349817731705617890688617614422279803126347527748253

e = 0x10001


# 	4266498038...60<621> = 2^2 · 3^3 · 5 · 29 · 6151 · 28387 · 368287 · 4236704544...59<603>


factors = [2,2,3,3,3,5,29,6151,28387,368287,423670454421213334672400536991628943356221715277223294069879222933831972255071814378880882434843236502035721741847404152855121751245150795796401189156176542809441908476460981081696513826624220851189805775606509173997102688295627090158555594501302944634303969330792934577990951710610190728041196421560594366766340576997502185120289666832929549573337937182488888923238303881587837011897794386659283020826114157463484846633708915440618064457186686723384698491441816873782787381341564084265288455105558793228845621354424686616054914764216216043308999026847126138945497969421346971744946054872589946439224959]

savephi=0

for i in range(len(factors)):
    fact = combinations(factors, i+1)
    for f in fact:
        phi = 1
        for k in f:
            phi = phi*k
        plus = N-phi+1
        minus = plus**2-4*N
        minus = gmpy2.iroot(minus, 2)
        if minus[1]:
            savephi=phi
            break
    if savephi!=0:
        break

ps = [107273, 80021, 110281, 125399, 77641]

ds = [] 

for i in range(len(ps)):
    ds.append(inverse(ps[i], phi))

c = 2621668640772056420471560098924704127784856790481388457844412769822118088860174800889321751481674422274270598394172919656578632970378187564960846030071830293875552723490431731972841568891484366856527528595054839456764493791012121047269761236912586905892771816051261702781783915560998982829509529868080760864895962974173385898354122495270178096361803788632815673814331531474332060419597040425174040815031894440262657639509623993308964349172916870911290368660953787873798343194799625182081014696063160131605363197089825537641567810410348240587342655465209891653946637101421879415183319402455214734741851508514452049810

for i in range(len(ds)):
    c = pow(c, ds[i], N)

print(long_to_bytes(c))

```

